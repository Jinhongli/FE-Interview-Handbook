# JAVASCRIPT 相关问题

## 解释下事件代理

将 DOM 元素注册的时间绑定在其父元素（或者祖先元素）上。其原理是：JS 对 DOM 事件的处理包括三个阶段：**捕获**、**目标**、**冒泡**。事件从根元素捕获至目标元素，再从目标元素冒泡至根元素，即事件会经过目标元素的父元素。这样做的好处：

* 节省内存。
* 新增元素之后不需要再绑定事件。

## 解释下 JS 中`this`

首先`this`的值只与函数的调用方式有关：

* `new`方式调用，`this`是生成的实例对象。
* `call`，`apply`和`bind`调用，`this`是传入的实参。
* 如果是对象的方法调用，`this`是该对象。
* 如果是作为普通函数调用，`this`非严格模式下是全局对象，浏览器中的`window`；严格模式下是`undefined`。（因为非严格模式下函数中找不到`this`就会去全局查找变量，而全局的`this`就是全局变量本身）
* ES6 中的箭头函数没有`this`，其内的`this`是箭头函数父环境下的`this`。

如果函数的调用存在多种情况，那么上面判断方法的优先级从上倒下降低。

## 解释下原型继承

关于原型和原型继承：

1. 每个函数（除`.bind()`绑定的函数）都包含一个`prototype`属性，指向其原型。
2. 所有的对象均具有一个内部`[[Prototype]]`属性，指向生成该对象的构造函数的原型，又称为该对象的原型对象。（浏览器中可以通过`__proto__`访问器属性查看）
3. 当前对象上查找不到的属性，就会去其`[[Prototype]]`属性指向的原型对象中查找。

这就是我们通常说的原型继承。并且由于原型对象也是对象，所以在原型对象上没有的属性，就回去原型对象的原型对象上再去查找，以此类推，直至`Object`的原型对象`null`为止。这就是 JS 中另一个非常重要的概念，原型链。

但是原型链有一些副作用：

1. 查找不存在的属性时，会遍历整个原型链。
2. 遍历对象的属性（`for in`）时，其原型链上的每个可枚举属性都会被遍历。
3. 只能修改删除对象自身的属性。

## AMD 和 CommonJS 的异同

都是为了 JS 的模块化开发（在 ES6 出现之前）。

- CommonJS 是同步的；而 AMD（Asynchronous Module Definition）是异步的。
- CommonJS的适合在服务器端运行；而AMD由于是异步的，所以在浏览器端更合适。
- 从语法上来说，AMD更为细致；而CommonJS更像其他语言中的`import`。并且Node开发中也是CommonJS的写法，避免了在开发中切换语法环境。
- 现在更为流行的是将所有JS文件打包成一个js文件，所以AMD的这种异步加载模块的方式的作用没有那么大了。

不过现在ES6中已经原生支持JS模块化了，并且支持同步与异步加载。虽然还有浏览器和低版本Node不支持原生ES6模块，但是可以通过转译器（例如Babel）来实现。

**参考：**
1. [https://auth0.com/blog/javascript-module-systems-showdown/](https://auth0.com/blog/javascript-module-systems-showdown/)